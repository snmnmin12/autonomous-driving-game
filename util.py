'''
File: Util
----------
This file contains several helper methods and a Belief class that you
can (and should) use to answer the various parts of the Driverless
Car assignment. Read each method description!

In addition to the Belief class, this file contains the
following helper methods:
 saveTransProb()
 loadTransProb()
 xToCol(x)
 yToRow(y)
 colToX(col)
 rowToY(row)
 pdf(mean, std, value)
 weightedRandomChoice(weightDict)
 
Licensing Information: Please do not distribute or publish solutions to this
project. You are free to use and extend Driverless Car for educational
purposes. The Driverless Car project was developed at Stanford, primarily by
Chris Piech (piech@cs.stanford.edu). It was inspired by the Pacman projects.
'''

from const import Const
import cPickle as pickle
import math
import os.path
import heapq,random

# Function: Save Trans Prob
# -------------------------
# Saves the transition probabilities that have been generated by running
# "learner." The transDict can by a dictionary of any type that you design.
# For example it could be a dictionary of tuples that are associated with
# their own dictionaries.
def saveTransProb(transDict, transFile):
    pickle.dump(transDict, transFile)

# Function: Load Trans Prob
# -------------------------
# Loads the transition probabilities that have been generated by running
# "learner." 
def loadTransProb():
    transFileName = Const.WORLD + 'TransProb.p'
    transFilePath = os.path.join('learned', transFileName)
    with open(transFilePath) as transFile:
        return pickle.load(transFile)
    raise Exception('could not load ' + transFilePath + '. Did you run learner on this layout?')

# Function: X to Col
# -------------------------
# Returns the col in the discretized grid, that the value x falls into.
# This function does not check that x is in bounds.
# Warning! Do not confuse rows and columns!
def xToCol(x):
    return int((x / Const.BELIEF_TILE_SIZE))

# Function: Y to Row
# -------------------------
# Returns the row in the discretized grid, that the value y falls into.
# This function does not check that y is in bounds.
# Warning! Do not confuse rows and columns!
def yToRow(y):
    return int((y / Const.BELIEF_TILE_SIZE))

# Function: Row to y
# -------------------------
# Returns the y value of the center of a tile in row in the discretized grid.
# This function does not check that row is in bounds.
# Warning! Do not confuse x and y!
def rowToY(row):
    return (row + 0.5) * Const.BELIEF_TILE_SIZE

# Function: Col to x
# -------------------------
# Returns the x value of the center of a tile in col in the discretized grid.
# This function does not check that col is in bounds.
# Warning! Do not confuse x and y!
def colToX(col):
    return (col + 0.5) * Const.BELIEF_TILE_SIZE

#function to find the nearest center of the belief block
def corToCenter(pos):
    x = pos[0]
    y = pos[1]
    col = xToCol(x)
    row = yToRow(y)
    newx = colToX(col)
    newy = rowToY(row)
    return (newx, newy)
# Function: Pdf
# -------------------------
# Returns the Guassian (aka Normal) probability density of a distribution with
# a given mean and std producing a given value.
def pdf(mean, std, value):
    u = float(value - mean) / abs(std)
    y = (1.0 / (math.sqrt(2 * math.pi) * abs(std))) * math.exp(-u * u / 2.0)
    return y

# Function: Weighted Random Choice
# --------------------------------
# Given a dictionary of the form element -> weight, selects an element
# uniformly over the different weights.
def weightedRandomChoice(weightDict):
    weights = []
    elems = []
    for elem in weightDict:
        weights.append(weightDict[elem])
        elems.append(elem)
    total = sum(weights)
    key = random.uniform(0, total)
    runningTotal = 0.0
    chosenIndex = None
    for i in range(len(weights)):
        weight = weights[i]
        runningTotal += weight
        if runningTotal > key:
            chosenIndex = i
            return elems[chosenIndex]
    raise Exception('Should not reach here')

# Class: Belief
# ----------------
# This class represents the belief for a single inference state of a single 
# car. It has one belief value for every tile on the map. You *must* use
# this class to store your belief values. Not only will it break the 
# visualization and simulation control if you use your own, it will also
# break our autograder :).
class Belief(object):
    
    # Function: Init
    # --------------
    # Constructor for the Belief class. It creates a belief grid which is
    # numRows by numCols. As an optional third argument you can pass in a the
    # initial belief value for every tile (ie Belief(3, 4, 0.0) would create
    # a belief grid with dimensions (3, 4) where each tile has belief = 0.0.
    def __init__(self, numRows, numCols, value = None):
        self.numRows = numRows
        self.numCols = numCols
        numElems = numRows * numCols
        if value == None:
            value = (1.0 / numElems)
        self.grid = [[value for _ in range(numCols)] for _ in range(numRows)]
        
    # Function: Set Prob
    # ------------------
    # Sets the probability of a given row, col to be p
    def setProb(self, row, col, p):
        self.grid[row][col] = p
        
    # Function: Add Prob
    # ------------------
    # Increase the probability of row, col by delta. Belief probabilities are
    # allowed to increase past 1.0, but you must later normalize.
    def addProb(self, row, col, delta):
        self.grid[row][col] += delta
        assert self.grid[row][col] >= 0.0
        
    # Function: Get Prob
    # ------------------
    # Returns the belief for tile row, col.
    def getProb(self, row, col):
        return self.grid[row][col]
    
    # Function: Normalize
    # ------------------
    # Makes the sum over all beliefs 1.0 by dividing each tile by the total.
    def normalize(self):
        total = self.getSum()
        for r in range(self.numRows):
            for c in range(self.numCols):
                self.grid[r][c] /= total
    
    # Function: Get Num Rows
    # ------------------
    # Returns the number of rows in the belief grid.
    def getNumRows(self):
        return self.numRows
    
    # Function: Get Num Cols
    # ------------------
    # Returns the number of cols in the belief grid.
    def getNumCols(self):
        return self.numCols
    
    # Function: Get Sum
    # ------------------
    # Return the sum of all the values in the belief grid. Used to make sure
    # that the matrix has been normalized.
    def getSum(self):
        total = 0.0
        for r in range(self.numRows):
            for c in range(self.numCols):
                total += self.getProb(r, c)
        return total
"""
 Data structures useful for implementing the algorithms
"""

class Stack:
    "A container with a last-in-first-out (LIFO) queuing policy."
    def __init__(self):
        self.list = []

    def push(self,item):
        "Push 'item' onto the stack"
        self.list.append(item)

    def pop(self):
        "Pop the most recently pushed item from the stack"
        return self.list.pop()

    def isEmpty(self):
        "Returns true if the stack is empty"
        return len(self.list) == 0

class Queue:
    "A container with a first-in-first-out (FIFO) queuing policy."
    def __init__(self):
        self.list = []

    def __len__(self):
        return len(self.list)

    def __getitem__(self, i):
        return self.list[i]

    def push(self,item):
        "Enqueue the 'item' into the queue"
        self.list.insert(0,item)

    def pop(self):
        """
          Dequeue the earliest enqueued item still in the queue. This
          operation removes the item from the queue.
        """
        return self.list.pop()

    def isEmpty(self):
        "Returns true if the queue is empty"
        return len(self.list) == 0

class PriorityQueue:
    """
      Implements a priority queue data structure. Each inserted item
      has a priority associated with it and the client is usually interested
      in quick retrieval of the lowest-priority item in the queue. This
      data structure allows O(1) access to the lowest-priority item.

      Note that this PriorityQueue does not allow you to change the priority
      of an item.  However, you may insert the same item multiple times with
      different priorities.
    """
    def  __init__(self):
        self.heap = []
        self.count = 0

    def push(self, item, priority):
        # FIXME: restored old behaviour to check against old results better
        # FIXED: restored to stable behaviour
        entry = (priority, self.count, item)
        # entry = (priority, item)
        heapq.heappush(self.heap, entry)
        self.count += 1

    def pop(self):
        (_, _, item) = heapq.heappop(self.heap)
        #  (_, item) = heapq.heappop(self.heap)
        return item

    def isEmpty(self):
        return len(self.heap) == 0

class PriorityQueueWithFunction(PriorityQueue):
    """
    Implements a priority queue with the same push/pop signature of the
    Queue and the Stack classes. This is designed for drop-in replacement for
    those two classes. The caller has to provide a priority function, which
    extracts each item's priority.
    """
    def  __init__(self, priorityFunction):
        "priorityFunction (item) -> priority"
        self.priorityFunction = priorityFunction      # store the priority function
        PriorityQueue.__init__(self)        # super-class initializer

    def push(self, item):
        "Adds an item to the queue with priority from the priority function"
        PriorityQueue.push(self, item, self.priorityFunction(item))

'''usefu for obseration'''
import math

class SonarObservation(object):

    def __init__(self, dist):
        self.dist = dist

    def getDist(self):
        return self.dist

class Observation(object):
    
    RADIUS = 3
    
    def __init__(self, pos):
        self.pos = pos
        self.output = True
        
    def remove(self, display):
        assert(self.parts)
        display.remove(self.parts)
        
    def getX(self):
        return self.pos.x
    
    def getY(self):
        return self.pos.y
        
    def getRow(self):
        row = Discretization.yToRow(self.pos.y)
        if not self.output:
            print '---------'
            print self.pos.y
            print self.pos.y / Const.BELIEF_TILE_SIZE
            print int(self.pos.y / Const.BELIEF_TILE_SIZE)
            print round(self.pos.y / Const.BELIEF_TILE_SIZE)
            print '---------'
        self.output = True
        return row
    
    def getCol(self):
        return Discretization.xToCol(self.pos.x)


def manhattanDistance( xy1, xy2 ):
    "Returns the Manhattan distance between points xy1 and xy2"
    return abs( xy1[0] - xy2[0] ) + abs( xy1[1] - xy2[1] )

    
def normalize(vectorOrCounter):
    """
    normalize a vector or counter by dividing each value by the sum of all values
    """
    normalizedCounter = Counter()
    if type(vectorOrCounter) == type(normalizedCounter):
        counter = vectorOrCounter
        total = float(counter.totalCount())
        if total == 0: return counter
        for key in counter.keys():
            value = counter[key]
            normalizedCounter[key] = value / total
        return normalizedCounter
    else:
        vector = vectorOrCounter
        s = float(sum(vector))
        if s == 0: return vector
        return [el / s for el in vector]

def sample(distribution, values = None):
    if type(distribution) == Counter:
        items = sorted(distribution.items())
        distribution = [i[1] for i in items]
        values = [i[0] for i in items]
    if sum(distribution) != 1:
        distribution = normalize(distribution)
    choice = random.random()
    i, total= 0, distribution[0]
    while choice > total:
        i += 1
        total += distribution[i]
    return values[i]
class Counter(dict):

    def __getitem__(self, idx):
        self.setdefault(idx, 0)
        return dict.__getitem__(self, idx)

    def totalCount(self):
        """
        Returns the sum of counts for all keys.
        """
        return sum(self.values())
        
    def argMax(self):
        """
        Returns the key with the highest value.
        """
        if len(self.keys()) == 0: return None
        all = self.items()
        values = [x[1] for x in all]
        maxIndex = values.index(max(values))
        return all[maxIndex][0]

    def normalize(self):
        """
        Edits the counter such that the total count of all
        keys sums to 1.  The ratio of counts for all keys
        will remain the same. Note that normalizing an empty
        Counter will result in an error.
        """
        total = float(self.totalCount())
        if total == 0: return
        for key in self.keys():
            self[key] = self[key] / total



